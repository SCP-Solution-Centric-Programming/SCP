|        Good Part        | comment                                                                                                                                                                                                                                                                                                                                                                                           |
| :---------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   garbage collection    | simplifies programming by removing worries about memory management                                                                                                                                                                                                                                                                                                                                |
|     mevent passing      | aka message-passing events                                                                                                                                                                                                                                                                                                                                                                        |
|                         | {tag, payload}                                                                                                                                                                                                                                                                                                                                                                                    |
|                         | not just dataflow/message-passing - each message packet causes a reaction, in order of arrival, at some point in the future                                                                                                                                                                                                                                                                       |
|                         | missing concept from most popular programming languages                                                                                                                                                                                                                                                                                                                                           |
|         fan-out         | one output port feeds many input ports                                                                                                                                                                                                                                                                                                                                                            |
|                         | requires memory management (e.g. GC), due to fact that mevents must be copied / duplicated / treated-as-copy-on-write                                                                                                                                                                                                                                                                             |
|                         | counter-example: UNIX pipe descriptors ; UNIX expects 1:1 pipe connections, data is not copied - once a datum has been consumed by one receiver it is not available to other receivers                                                                                                                                                                                                            |
|                         | kernel needs to know data length to be able to make copies, e.g. tag each datum with byte-length or restrict datums to be of very few, well-known types - most general solution is to tag every datum with flexi-num length field (all other variations are optimizations to the general method (it might be worth trying the non-optimized version first, then tweak it for special use-cases?)) |
|         fan-in          |                                                                                                                                                                                                                                                                                                                                                                                                   |
|      backtracking       | vanquished in early 1960s due to concerns about efficiency                                                                                                                                                                                                                                                                                                                                        |
|                         | basic operation of Prolog - the granddaddy of Relational Programming                                                                                                                                                                                                                                                                                                                              |
|                         | easy to implement in Javascript (see Ohm in Small Steps PDF)                                                                                                                                                                                                                                                                                                                                      |
|          *t2t*          | text to text transpilation                                                                                                                                                                                                                                                                                                                                                                        |
|                         | e.g. transpile new programming languages to existing programming languages                                                                                                                                                                                                                                                                                                                        |
|    async by default     | popular programming languages are exactly the opposite - they implement synchronousity by default                                                                                                                                                                                                                                                                                                 |
|                         | probable cause of many internet/distribute-programming problems like callback hell                                                                                                                                                                                                                                                                                                                |
|                         | needed to make programming robots simpler                                                                                                                                                                                                                                                                                                                                                         |
|                         | needed to make programming gaming NPCs simpler                                                                                                                                                                                                                                                                                                                                                    |
|        drawware         | compile drawings *to* running code                                                                                                                                                                                                                                                                                                                                                                |
|                         | not conversion of textual code to drawings, like plantUML, Mermaid, graphviz                                                                                                                                                                                                                                                                                                                      |
|                         | easy to do using *t2t* and *.drawio* files                                                                                                                                                                                                                                                                                                                                                        |
|                         | existing tools, like OhmJS, YACC, etc. are designed to operate on text, hence, we need to bridge the gap between drawings and text                                                                                                                                                                                                                                                                |
|   multiple paradigms    | paradigms are important, syntax is cheap                                                                                                                                                                                                                                                                                                                                                          |
|                         | UNIX pipelines and processes form the germ of ideas for how to do this                                                                                                                                                                                                                                                                                                                            |
|                         | UNIX pipeline and processes demonstrate how useful this technique can be                                                                                                                                                                                                                                                                                                                          |
|                         | one SCN per paradigm, multiple SCNs per project                                                                                                                                                                                                                                                                                                                                                   |
|       coroutines        | fundamental technique for implementing multi-tasking operating systems                                                                                                                                                                                                                                                                                                                            |
|        closures         | closures with multiple "entry points" == OOP                                                                                                                                                                                                                                                                                                                                                      |
|     vector graphics     | overlapping figures (as opposed to grids of non-overlapping pixmaps (aka "characters"))                                                                                                                                                                                                                                                                                                           |
|                         | "text" is just a figure (SVG)                                                                                                                                                                                                                                                                                                                                                                     |
|                         | new opportunity for syntax                                                                                                                                                                                                                                                                                                                                                                        |
|    OSI layered model    | layers instead of infinite canvases                                                                                                                                                                                                                                                                                                                                                               |
|                         | "narrow waists" before the term "narrow waists" was coined                                                                                                                                                                                                                                                                                                                                        |
|                         | simple types at low levels (e.g. transport layer)                                                                                                                                                                                                                                                                                                                                                 |
|                         | increasing type complexity, in increasingly higher layers, layered types                                                                                                                                                                                                                                                                                                                          |
|                         | layered types, incremental typing                                                                                                                                                                                                                                                                                                                                                                 |
|                         | payloads wrapped in concentric bracketed scopes, like onion skins                                                                                                                                                                                                                                                                                                                                 |
|     algebraic types     | type1 \| type2                                                                                                                                                                                                                                                                                                                                                                                    |
|           PEG           | parsing expression grammars                                                                                                                                                                                                                                                                                                                                                                       |
|                         | DSL for parsing text                                                                                                                                                                                                                                                                                                                                                                              |
|                         | backtracking and prioritization simplifies grammar writing                                                                                                                                                                                                                                                                                                                                        |
|                         | better than REGEX, due to use of stack, but enables writing quicky patterns                                                                                                                                                                                                                                                                                                                       |
|      dictionaries       | key / value                                                                                                                                                                                                                                                                                                                                                                                       |
|                         | early version - Lisp ALISTs                                                                                                                                                                                                                                                                                                                                                                       |
|                         | hash table                                                                                                                                                                                                                                                                                                                                                                                        |
|         scoping         | lines of code, not scoped, were caused by punch-card mentality                                                                                                                                                                                                                                                                                                                                    |
|                         | lack of scoping led to "global variable" problem                                                                                                                                                                                                                                                                                                                                                  |
|                         | Lisp parenthesized syntax is fully scoped, unlike most popular { ... } line-oriented PLs                                                                                                                                                                                                                                                                                                          |
|                         | scoping learned in kindergarten (don't colour outside of the lines)                                                                                                                                                                                                                                                                                                                               |
|                         | [tree-oriented programming](https://programmingsimplicity.substack.com/p/tree-oriented-programming-instead?r=1egdky)                                                                                                                                                                                                                                                                              |
|       StateCharts       | Parental Authority instead of class-based inheritance                                                                                                                                                                                                                                                                                                                                             |
|                         | DSL for control flow programming                                                                                                                                                                                                                                                                                                                                                                  |
|                         | DPL for control flow (DPL == Diagrammatic Programming Language)                                                                                                                                                                                                                                                                                                                                   |
| prototypal inheritance  | [Self](https://en.wikipedia.org/wiki/Self_(programming_language))                                                                                                                                                                                                                                                                                                                                 |
|                         | Javascript                                                                                                                                                                                                                                                                                                                                                                                        |
|                         | does not emphasize *optimization* as does class-based inheritance                                                                                                                                                                                                                                                                                                                                 |
|                         | can reconfigure object at runtime / development time                                                                                                                                                                                                                                                                                                                                              |
|  first class functions  |                                                                                                                                                                                                                                                                                                                                                                                                   |
| side effect containment | necessary in FP and Microsoft Word (search & replace)                                                                                                                                                                                                                                                                                                                                             |
|                         | UNIX processes contain control flow and encapsulate data - same result different paradigm                                                                                                                                                                                                                                                                                                         |
|                         | FP attempts to achieve "referential transparency", previously known as "pin for pin compatible" in electronics design                                                                                                                                                                                                                                                                             |
|   string manipulation   | string matching and replacement, like REGEX, s.replace (...,...), etc.                                                                                                                                                                                                                                                                                                                            |
|          UNIX           | processes                                                                                                                                                                                                                                                                                                                                                                                         |
|                         | multi-language development - apps run in processes, apps may contain different programming languages                                                                                                                                                                                                                                                                                              |
|                         | simple transport layer - character streams, but \n terminated                                                                                                                                                                                                                                                                                                                                     |
|                         | pipelines                                                                                                                                                                                                                                                                                                                                                                                         |
|                         | ports - FDs defined by O/S, but, 1-in, 1-out only                                                                                                                                                                                                                                                                                                                                                 |
|                         | pipes shown to be useful, but, overly restrictive due to /bin/sh text format                                                                                                                                                                                                                                                                                                                      |
|                         | IPC does not inherently support fan-out, need extra app like `tee`                                                                                                                                                                                                                                                                                                                                |
|  Sector Lisp, Lisp 1.5  | implements Lambda                                                                                                                                                                                                                                                                                                                                                                                 |
|                         |                                                                                                                                                                                                                                                                                                                                                                                                   |
# Possibilities
## Multi-paradigm IDEs
The idea of cramming all features into one programming language is outdated. The idea was formed in the 1960s, when it was still considered to be hard to create new programming languages and DSLs and programmers were still searching for workflows that helped build programs. 

In fact, "programming" was borne out of the desire to create software for single ICs - CPUs - within circuits that could contain many CPUs and other kinds of chips.

We are backing into this mentality, again, - use of multiple paradigms - by offloading work to other circuits and chips, for example GPUs, postscript printers, etc.

Today, creating PLs is much easier. One possible direction is to use a workflow that incorporates many paradigms in a single program, each paradigm with its own little PL. I call these SCNs - for Solution Centric Notations.

- async by default
- pong
- two-tier approach forth, sector lisp as virtual machine, target for TaS, vs. functions written in lower level language (JS, Rust, etc.)
- recursive syntax instead of line-oriented syntax

# Footnotes
## Ohm In Small Steps 
- early experiment and working paper for mapping Nils Holm's Prolog in Scheme to Javascript
- contains working `.ohm` grammar for transpilation of `prolog.scm` to `prolog.js`
- needs upgrading, hasn't been revisited for about 5 years
- [Ohm In Small Steps](https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html)

## t2t
- [Experiments With Text to Text Transpilation](https://programmingsimplicity.substack.com/p/experiments-with-text-to-text-transpilation?r=1egdky)
- [Writing a JSON Parser Using T2T in Only 2.5 Hours](https://programmingsimplicity.substack.com/p/writing-a-json-parser-using-t2t-in?r=1egdky)
- [RWR (rewrite specification) Documentation](https://github.com/guitarvydas/pbp-dev/blob/dev/t2t/doc/rwr/RWR%20Spec.pdf)

## draw.io
- [drawio]([https://app.diagrams.net](https://app.diagrams.net)
- drawing editor that saves drawings out in textual [.graphML]([http://graphml.graphdrawing.org](http://graphml.graphdrawing.org)) format
- since drawings are converted to text, *t2t* can be used to transpile them to existing languages (e.g. Python)
- example: [arith](https://github.com/guitarvydas/arith)

## SCN
- [SCN](https://guitarvydas.github.io/2021/04/10/SCN.html)
- [Type SCN](https://guitarvydas.github.io/2021/07/05/Type-DSL-(SCN).html)
- [SCN Development for ZodeTrip](https://guitarvydas.github.io/2021/09/02/SCN-Development.html)
- [SCN Development for ZodeTrip (again)](https://guitarvydas.github.io/2021/12/31/SCN-development.html)
- [Find and Replace SCN](https://guitarvydas.github.io/2023/09/24/Find-and-Replace-SCN.html)

# References
## Notations Based on Gutenberg Typesetting
- Iverson's "Notation as a Tool of Thought" Turing Award speech https://doi.org/10.1145/358896.358899
### Tools
- Racket LOP: https://docs.racket-lang.org/guide/hash-languages.html
- t2t (see above)

## Non-Gutenberg Notations
### pong
- schematics
	- https://archive.org/details/pongschematics/mode/1up?view=theater
	- https://www.reddit.com/r/EngineeringPorn/comments/ul49zt/the_original_pong_video_game_had_no_code_and_was/
- LUA version
	- https://www.youtube.com/watch?v=jZqYXSmgDuM
	
### statecharts
- https://guitarvydas.github.io/2023/11/27/Statecharts-Papers-We-Love-Video.html
- https://guitarvydas.github.io/2021/02/25/statecharts-(again).html
### Beyond Text
- https://ianarawjo.therottingcartridge.com/docs/To_Write_Code_Arawjo_CHI2020.pdf
- https://ianarawjo.medium.com/on-notational-programming-for-notebook-environments-710a7b4f35e6
### Tools
- draw.io DaS - [repo in need of better release cleanup](https://github.com/guitarvydas/pbp-dev/tree/dev/das)
- [PBP](https://www.youtube.com/playlist?list=PLHh2_dCKBPjYBmubkBfn0LSbDMRKsr9Ui)
- [FBP](https://jpaulm.github.io/fbp/index.html)